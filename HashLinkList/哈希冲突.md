# 开放寻址法

### 线性探查

将关键字序列（7，8，30，11，18，9，14）散列存储到散列表中，散列表的存储空间是一个下标从0开始的一堆数组，散列函数为H(key) = (key*3) MOD 7,处理冲突采用线性探测再散列法，要求装填因子为0.7。

- （1）.请画出所构造的散列表

- （2）.分别计算出等概率情况下查找成功和查找不成功的平均查找长度。

  ### 解析

根据题意可知，哈希表的长度L = 7/0.7 = 10, 因此此题需要构建的哈希表是下标0-9的一维函数，同时散列函数为H(key) = (key*3) MOD 7，故计算得到下表

| key    | 7    | 8    | 30   | 11   | 18   | 9    | 14   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| H(key) | 0    | 3    | 6    | 5    | 5    | 6    | 0    |

由此可以发现散列表中当key为7，14和11，18时，H(key)相同，在构建散列表时，产生了哈希冲突，所有需要通过冲突处理办法解决，开放寻址法，通过线性探测再散列法处理冲突，所构造的散列表为

第一个key为7, H(key) = 0, index为0的数组上无关键字，因此可以没有冲突的放入位置0；

第二个key为8, H(key) = 3, index为3的数组上无关键字，因此可以没有冲突的放入位置3；

第三个key为30, H(key) = 6, index为6的数组上无关键字，因此可以没有冲突的放入位置6；

第四个key为11, H(key) = 5, index为5的数组上无关键字，因此可以没有冲突的放入位置5；

第五个key为18, H(key) = 5,index为5的数组上已有关键字11，出现冲突，根据线性探测再散列法来处理这个冲突，探测下一个位置为6，但是6同样已有关键字，因此继续探测下一个位置为7，放入key 18;

第六个key为9，H(key)=6，index为6的数组上已有关键字，因此按照+1步长进行探测，找到下一个空余节点index8；

第7个key为14，H(key)= 0, index为0的数组已有关键字，因此因此按照+1步长进行探测，找到下一个空余节点index1；

| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| key   | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |

关于等概率情况下查找成功平均查找长度ASL，可以根据第一问的构造过程求解:

key7，8，30，11都是一次探测就插入了数组，而18，9则分别探测了3次，key18探测了index5，6，7，key9探测了index6，7，8，同理key14探测了index0，1，ASLsuccess = （1+1+1+1+3+3+2）/ 7 = 12 / 7

| key   | 7    | 8    | 30   | 11   | 18   | 9    | 14   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| count | 1    | 1    | 1    | 1    | 3    | 3    | 2    |

同时等概率情况下查找不成功的平均查找长度，计算查找不成功的次数就直接找关键字到第一个地址上关键字喂空的距离即可，因为MOD7，所以初始地址只可能在index0~6，

index0，到第一个为空的地址index2的距离是3，所以不成次数为3；

index1，到第一个为空的地址index2的距离是2，所以不成次数为2；

index2，到第一个为空的地址index2的距离是1，所以不成次数为1；

index3，到第一个为空的地址index4的距离是2，所以不成次数为2；

index4，到第一个为空的地址index4的距离是1，所以不成次数为1；

index5，到第一个为空的地址index2的距离是5，(5,6,0,1,2),所以不成次数为5；

index6，到第一个为空的地址index4的距离是4，(6,0,1,2),所以不成次数为4;

| key   | 7    | 8    | 30   | 11   | 18   | 9    | 14   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| count | 3    | 2    | 1    | 2    | 1    | 5    | 4    |

ASLunsuccess = （3+2+1+2+1+5+4）/ 7 = 18 / 7

### 二次探测

所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0²，hash(key)+1²，hash(key)+2²……

U = {0, 1, 7}

同样的，我们先将0、1哈希到表的0、1位置，且未发生冲突。
接下来，我们对7进行哈希，发现 h0(7)= ( 7 + 0^2 ) % 7 = 0 ，且0号位置已被占用，则进行冲突解决，尝试 h1(7)= ( 7 + 1^2 ) % 7 = 1 ，发现1号位置同样被占用，继续探查， h2(7)= ( 7 + 2^2 ) % 7 = 4，此时4号位置未被占用，则将7放入4号位置，冲突解决。

| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 0    | 1    |      |      | 7    |      |      |

### 双重探测

双重探查也称二次再散列法，是指第一次散列产生哈希地址冲突，为了解决冲突，采用另外的散列函数或者对冲突结果进行处理的方法。
在双重探查中，F ( i ) 是一个新的哈希函数的值的整数倍。
通常情况下，我们有：
hi(x)= ( Hash( x ) + i*Hash1( x ) ) % TableSize
其中Hash1( x )是一个不同于Hash( x )的新的哈希函数。

U = {0, 1, 2, 7}

| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 0    | 1    |      |      | 7    |      |      |

在这里，0、1、2被哈希到0、1、2的位置，且未发生哈希冲突。
对7进行哈希计算，发现 h0(7)= ( 7 + 0^2 ) % 7 = 0 ，0号位置已经被占用，发生哈希冲突，则进行解决，尝试 h1(7)= ( 7 + 1*(7 mod 5) ) % 7 = 2，发现2号位置同样被占用，则继续探查， h2(7)= ( 7 + 2*(7 mod 5) ) % 7 = 4，发现4号位置为空，则将7放入4号位置，解决冲突。

# 链接法

链接法的构思来源于链表的启发，将被哈希到哈希表同一位置的数通过链表进行连接，使得他们能够在哈希表中共存，从而解决了哈希冲突

![image-20211108101526783](/Users/jing/Library/Application Support/typora-user-images/image-20211108101526783.png)

如图所示，被哈希到同一位置的k1、k4；k5、k2、k7；k8、k6这三组数，被按照先后哈希的顺序，以双向链表的形式进行链接，从而共同被保存在哈希表中，解决了哈希冲突。
